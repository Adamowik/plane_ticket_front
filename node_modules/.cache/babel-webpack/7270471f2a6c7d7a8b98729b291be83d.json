{"ast":null,"code":"import _classCallCheck from \"C:/Users/AdamWo\\u017Aniakowski/Desktop/Studia/AI/plane-tickets-app-master(front)/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport * as ɵngcc0 from '@angular/core';\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { Injectable, Inject, Optional, NgZone, PLATFORM_ID } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, from, of, throwError } from 'rxjs';\nimport { mergeMap, catchError, map, switchMap, concat, defaultIfEmpty, observeOn } from 'rxjs/operators';\nimport { ɵAngularFireSchedulers, _firebaseAppFactory, FIREBASE_APP_NAME, FIREBASE_OPTIONS } from '@angular/fire';\n\nvar AngularFireMessaging = function AngularFireMessaging(options, nameOrConfig, platformId, zone) {\n  var _this = this;\n\n  _classCallCheck(this, AngularFireMessaging);\n\n  var schedulers = new ɵAngularFireSchedulers(zone);\n  var requireMessaging = from(import('firebase/messaging'));\n  this.messaging = requireMessaging.pipe(observeOn(schedulers.outsideAngular), map(function () {\n    return _firebaseAppFactory(options, zone, nameOrConfig);\n  }), map(function (app) {\n    return app.messaging();\n  }));\n\n  if (!isPlatformServer(platformId)) {\n    this.requestPermission = this.messaging.pipe(observeOn(schedulers.outsideAngular), switchMap(function (messaging) {\n      return messaging.requestPermission();\n    }));\n  } else {\n    this.requestPermission = throwError('Not available on server platform.');\n  }\n\n  this.getToken = this.messaging.pipe(observeOn(schedulers.outsideAngular), switchMap(function (messaging) {\n    return messaging.getToken();\n  }), defaultIfEmpty(null));\n  var tokenChanges = this.messaging.pipe(observeOn(schedulers.outsideAngular), switchMap(function (messaging) {\n    return new Observable(messaging.onTokenRefresh.bind(messaging)).pipe(switchMap(function () {\n      return messaging.getToken();\n    }));\n  }));\n  this.tokenChanges = this.getToken.pipe(concat(tokenChanges));\n  this.messages = this.messaging.pipe(observeOn(schedulers.outsideAngular), switchMap(function (messaging) {\n    return new Observable(messaging.onMessage.bind(messaging));\n  }));\n  this.requestToken = this.requestPermission.pipe(catchError(function () {\n    return of(null);\n  }), mergeMap(function () {\n    return _this.tokenChanges;\n  }));\n\n  this.deleteToken = function (token) {\n    return _this.messaging.pipe(observeOn(schedulers.outsideAngular), switchMap(function (messaging) {\n      return messaging.deleteToken(token);\n    }), defaultIfEmpty(false));\n  };\n};\n\nAngularFireMessaging.ɵfac = function AngularFireMessaging_Factory(t) {\n  return new (t || AngularFireMessaging)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n};\n\nAngularFireMessaging.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: AngularFireMessaging,\n  factory: function factory(t) {\n    return AngularFireMessaging.ɵfac(t);\n  }\n});\nAngularFireMessaging = __decorate([__param(0, Inject(FIREBASE_OPTIONS)), __param(1, Optional()), __param(1, Inject(FIREBASE_APP_NAME)), __param(2, Inject(PLATFORM_ID)), __metadata(\"design:paramtypes\", [Object, Object, Object, NgZone])], AngularFireMessaging);\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(AngularFireMessaging, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [FIREBASE_OPTIONS]\n      }]\n    }, {\n      type: Object,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [FIREBASE_APP_NAME]\n      }]\n    }, {\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, null);\n})();\n\nexport { AngularFireMessaging };","map":{"version":3,"sources":["../../../../src/messaging/messaging.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable, Inject, Optional, NgZone, PLATFORM_ID } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { messaging } from 'firebase/app';\nimport { Observable, empty, from, of, throwError } from 'rxjs';\nimport { mergeMap, catchError, map, switchMap, concat, defaultIfEmpty, observeOn } from 'rxjs/operators';\nimport { FirebaseOptions, FirebaseAppConfig, ɵAngularFireSchedulers, _firebaseAppFactory, FIREBASE_APP_NAME, FIREBASE_OPTIONS } from '@angular/fire';\n\n@Injectable()\nexport class AngularFireMessaging {\n  messaging: Observable<messaging.Messaging>;\n  requestPermission: Observable<void>;\n  getToken: Observable<string|null>;\n  tokenChanges: Observable<string|null>;\n  messages: Observable<{}>;\n  requestToken: Observable<string|null>;\n  deleteToken: (token: string) => Observable<boolean>;\n\n  constructor(\n    @Inject(FIREBASE_OPTIONS) options:FirebaseOptions,\n    @Optional() @Inject(FIREBASE_APP_NAME) nameOrConfig:string|FirebaseAppConfig|null|undefined,\n    @Inject(PLATFORM_ID) platformId: Object,\n    zone: NgZone\n  ) {\n    const schedulers = new ɵAngularFireSchedulers(zone);\n\n    // @ts-ignore zapping in the UMD in the build script\n    const requireMessaging = from(import('firebase/messaging'));\n\n    this.messaging = requireMessaging.pipe(\n      observeOn(schedulers.outsideAngular),\n      map(() => _firebaseAppFactory(options, zone, nameOrConfig)),\n      map(app => app.messaging()),\n    );\n\n    if (!isPlatformServer(platformId)) {\n\n      this.requestPermission = this.messaging.pipe(\n        observeOn(schedulers.outsideAngular),\n        switchMap(messaging => messaging.requestPermission()),\n      );\n\n    } else {\n\n      this.requestPermission = throwError('Not available on server platform.');\n\n    }\n\n    this.getToken = this.messaging.pipe(\n      observeOn(schedulers.outsideAngular),\n      switchMap(messaging => messaging.getToken()),\n      defaultIfEmpty(null),\n    );\n\n    const tokenChanges = this.messaging.pipe(\n      observeOn(schedulers.outsideAngular),\n      switchMap(messaging => new Observable(messaging.onTokenRefresh.bind(messaging)).pipe(\n        switchMap(() => messaging.getToken())\n      )),\n    );\n\n    this.tokenChanges = this.getToken.pipe(\n      concat(tokenChanges)\n    );\n\n    this.messages = this.messaging.pipe(\n      observeOn(schedulers.outsideAngular),\n      switchMap(messaging => new Observable(messaging.onMessage.bind(messaging))),\n    );\n\n    this.requestToken = this.requestPermission.pipe(\n      catchError(() => of(null)),\n      mergeMap(() => this.tokenChanges)\n    );\n\n    this.deleteToken = (token: string) => this.messaging.pipe(\n      observeOn(schedulers.outsideAngular),\n      switchMap(messaging => messaging.deleteToken(token)),\n      defaultIfEmpty(false),\n    );\n  }\n\n}\n"]},"metadata":{},"sourceType":"module"}